// vim: et ts=4 sw=4
grammar<'input>;
use super::{Error, lex::{self, Tok, TOK_NADA}};

pub Module: ast::Module<'input> =
    Item* => (<>,).into()
;

Item: ast::Item<'input> = {
    <Invocation> ";" => <>.into(),
    ";" => ast::Item::Empty(<_>::default()),
    "let" <Ident> "=" <Box<Body>> => ast::Item::LetStmt((<>,).into()),
    "def" <Ident> "=" <Box<Body>> => ast::Item::DefStmt((<>,).into()),
}
Invocation: ast::Invocation<'input> = {
    DocComment*
    InvocationTarget
    InvocationCwd?
    InvocationRedirection*
    InvocationEnv*
    InvocationArg*
    => (<>).into(),
}
InvocationTarget: ast::InvocationTarget<'input> = {
    Ident => ast::InvocationTarget::InvocationTargetLocal((<>,).into()),
    "!" <Ident> => ast::InvocationTarget::InvocationTargetSystemName((<>,).into()),
    Path => ast::InvocationTarget::InvocationTargetSystemPath((<>,).into()),
}
InvocationArg: ast::InvocationArg<'input> = {
    Ident => <>.into(),
    Word => <>.into(),
    Opt => <>.into(),
    Path => <>.into(),
    String => <>.into(),
    Variable => <>.into(),
}
InvocationCwd: ast::Path<'input> = "@" <Path>;
InvocationEnv: ast::InvocationEnv<'input> = <IDENT_NO_EQ> "=" <InvocationArg>;

InvocationRedirection: ast::InvocationRedirection<'input> = {
    "<" <Redirect> => ast::RedirectInput((<>,)).into(),
    ">" <Redirect> => ast::RedirectOutput((<>,)).into(),
}

Redirect: ast::Redirect<'input> = {
    Path => <>.into(),
    Variable => <>.into(),
}

Opt: ast::Opt<'input> = {
    ShortOpt => <>.into(),
    LongOpt => <>.into(),
}
Path: ast::Path<'input> = {
    AbsPath => <>.into(),
    RelPath => <>.into(),
    HomePath => <>.into(),
}

Variable: ast::Variable<'input> = {
    "$" <Ident> => (<>,).into(),
}

Body: ast::Body<'input> = {
    <Item> => <>.into(),
}


DocComment: ast::Text<'input> = DOC_COMMENT;
IdentSimple: ast::Ident<'input> = IDENT;
IdentNeq: ast::Ident<'input> = IDENT_NO_EQ;
Ident: ast::Ident<'input> = { IdentSimple, IdentNeq };
Word: ast::Word<'input> = WORD => (<>,).into();
String: ast::String<'input> = {
    DOUBLE_QUOTE_RAW_STRING => (<>,).into(),
    SINGLE_QUOTE_RAW_STRING => (<>,).into(),
}
AbsPath: ast::AbsPath<'input> = ABS_PATH => (<>,).into();
RelPath: ast::RelPath<'input> = REL_PATH => (<>,).into();
HomePath: ast::HomePath<'input> = HOME_PATH => (<>,).into();
LongOpt: ast::LongOpt<'input> = LONG_OPT => (<>,).into();
ShortOpt: ast::ShortOpt<'input> = SHORT_OPT => (<>,).into();

Box<T>: Box<T> = T => Box::new(<>);

extern {
    type Location = usize;
    type Error = Error;
    enum Tok<'input> {
        "let"               => Tok::Kwd     (lex::Kwd       ("let"          )   ),
        "def"               => Tok::Kwd     (lex::Kwd       ("def"          )   ),
        "="                 => Tok::Kwd     (lex::Kwd       ("="            )   ),
        "$"                 => Tok::Kwd     (lex::Kwd       ("$"            )   ),
        "\""                => Tok::Kwd     (lex::Kwd       ("\""           )   ),
        ";"                 => Tok::Kwd     (lex::Kwd       (";"            )   ),
        "@"                 => Tok::Kwd     (lex::Kwd       ("@"            )   ),
        "<"                 => Tok::Kwd     (lex::Kwd       ("<"            )   ),
        ">"                 => Tok::Kwd     (lex::Kwd       (">"            )   ),
        "!"                 => Tok::Kwd     (lex::Kwd       ("!"            )   ),
        IDENT               => Tok::Idnt    (lex::Idnt      (<&'input str>  )   ),
        IDENT_NO_EQ         => Tok::IdntNe  (lex::IdntNe    (<&'input str>  )   ),
        ABS_PATH            => Tok::AbsPath (lex::AbsPath   (<&'input str>  )   ),
        REL_PATH            => Tok::RelPath (lex::RelPath   (<&'input str>  )   ),

        // IDENT            r"[a-zA-Z_][a-zA-Z0-9:.,_=/-]*"
        // IDENT_NO_EQ      r"[a-zA-Z_][a-zA-Z0-9:.,_/-]*"
        // ABS_PATH         r"/[a-zA-Z0-9:.,_=/-]*"
        // REL_PATH         r"\./[a-zA-Z0-9:.,_=/-]*"


        // r"--[a-zA-Z0-9:.,_=/-]*"
        LONG_OPT                => Tok::Nada ( lex::Nada ( <&'input str> ) ),
        // r"~/[a-zA-Z0-9:.,_=/-]*"
        HOME_PATH               => Tok::Nada ( lex::Nada ( <&'input str> ) ),
        // r#""[^"]*""#
        DOUBLE_QUOTE_RAW_STRING => Tok::Nada ( lex::Nada ( <&'input str> ) ),
        // r#"'[^']*'"#
        SINGLE_QUOTE_RAW_STRING => Tok::Nada ( lex::Nada ( <&'input str> ) ),
        // r"#.*"
        DOC_COMMENT             => Tok::Nada ( lex::Nada ( <&'input str> ) ),
        // r"-[a-zA-Z0-9:.,_=/-]*"
        SHORT_OPT               => Tok::Nada ( lex::Nada ( <&'input str> ) ),
        // r"[a-zA-Z0-9:.,_=+/-]*"
        WORD                    => Tok::Nada ( lex::Nada ( <&'input str> ) ),
    }
}

//match {
//    "let",
//    "def",
//} else {
//    r"[a-zA-Z_][a-zA-Z0-9:.,_/-]*" => IDENT_NO_EQ,
//} else {
//    r"--[a-zA-Z0-9:.,_=/-]*" => LONG_OPT,
//    r"\./[a-zA-Z0-9:.,_=/-]*" => REL_PATH,
//    r"/[a-zA-Z0-9:.,_=/-]*" => ABS_PATH,
//    r"~/[a-zA-Z0-9:.,_=/-]*" => HOME_PATH,
//    r"[a-zA-Z_][a-zA-Z0-9:.,_=/-]*" => IDENT,
//    r#""[^"]*""# => DOUBLE_QUOTE_RAW_STRING,
//    r#"'[^']*'"# => SINGLE_QUOTE_RAW_STRING,
//    r"#.*" => DOC_COMMENT,
//    "=",
//    "$",
//    "\"",
//    ";",
//    "@",
//    "<",
//    ">",
//    "!",
//} else {
//    r"-[a-zA-Z0-9:.,_=/-]*" => SHORT_OPT,
//} else {
//    r"[a-zA-Z0-9:.,_=+/-]*" => WORD,
//}

